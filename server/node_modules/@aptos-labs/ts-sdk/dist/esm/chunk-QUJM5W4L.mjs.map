{"version":3,"sources":["../../src/core/crypto/multiKey.ts"],"sourcesContent":["import { SigningScheme as AuthenticationKeyScheme } from \"../../types\";\nimport { Deserializer } from \"../../bcs/deserializer\";\nimport { Serializer } from \"../../bcs/serializer\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { AccountPublicKey, PublicKey, VerifySignatureArgs } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { AnyPublicKey, AnySignature } from \"./singleKey\";\n\n/**\n * Counts the number of set bits (1s) in a byte.\n * This function can help you determine the population count of a given byte value.\n *\n * @param byte - The byte value for which to count the number of set bits.\n * @group Implementation\n * @category Serialization\n */\n/* eslint-disable no-bitwise */\nfunction bitCount(byte: number) {\n  let n = byte;\n  n -= (n >> 1) & 0x55555555;\n  n = (n & 0x33333333) + ((n >> 2) & 0x33333333);\n  return (((n + (n >> 4)) & 0xf0f0f0f) * 0x1010101) >> 24;\n}\n/* eslint-enable no-bitwise */\n\nexport abstract class AbstractMultiKey extends AccountPublicKey {\n  publicKeys: PublicKey[];\n\n  constructor(args: { publicKeys: PublicKey[] }) {\n    super();\n    this.publicKeys = args.publicKeys;\n  }\n\n  /**\n   * Create a bitmap that holds the mapping from the original public keys\n   * to the signatures passed in\n   *\n   * @param args.bits array of the index mapping to the matching public keys\n   * @returns Uint8array bit map\n   * @group Implementation\n   * @category Serialization\n   */\n  createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number, idx: number) => {\n      if (idx + 1 > this.publicKeys.length) {\n        throw new Error(`Signature index ${idx + 1} is out of public keys range, ${this.publicKeys.length}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(`Duplicate bit ${bit} detected.`);\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   * @category Serialization\n   */\n  getIndex(publicKey: PublicKey): number {\n    const index = this.publicKeys.findIndex((pk) => pk.toString() === publicKey.toString());\n\n    if (index !== -1) {\n      return index;\n    }\n    throw new Error(`Public key ${publicKey} not found in multi key set ${this.publicKeys}`);\n  }\n}\n\n/**\n * Represents a multi-key authentication scheme for accounts, allowing multiple public keys\n * to be associated with a single account. This class enforces a minimum number of valid signatures\n * required to authorize actions, ensuring enhanced security for multi-agent accounts.\n *\n * The public keys of each individual agent can be any type of public key supported by Aptos.\n * Since [AIP-55](https://github.com/aptos-foundation/AIPs/pull/263), Aptos supports\n * `Legacy` and `Unified` authentication keys.\n * @group Implementation\n * @category Serialization\n */\nexport class MultiKey extends AbstractMultiKey {\n  /**\n   * List of any public keys\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly publicKeys: AnyPublicKey[];\n\n  /**\n   * The minimum number of valid signatures required, for the number of public keys specified\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signaturesRequired: number;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   * This constructor initializes a multi-signature transaction with the provided signatures and bitmap.\n   *\n   * @param args An object containing the parameters for the multi-signature transaction.\n   * @param args.signatures A list of signatures.\n   * @param args.bitmap A bitmap represented as a Uint8Array or an array of numbers, where each bit indicates whether a\n   * corresponding signature is present. A maximum of 32 signatures is supported, and the length of the bitmap must be 4 bytes.\n   *\n   * @throws Error if the number of signatures exceeds the maximum supported, if the bitmap length is incorrect, or if the number\n   * of signatures does not match the bitmap.\n   * @group Implementation\n   * @category Serialization\n   */\n  // region Constructors\n  constructor(args: { publicKeys: Array<PublicKey>; signaturesRequired: number }) {\n    const { publicKeys, signaturesRequired } = args;\n    super({ publicKeys });\n\n    // Validate number of public keys is greater than signature required\n    if (signaturesRequired < 1) {\n      throw new Error(\"The number of required signatures needs to be greater than 0\");\n    }\n\n    // Validate number of public keys is greater than signature required\n    if (publicKeys.length < signaturesRequired) {\n      throw new Error(\n        `Provided ${publicKeys.length} public keys is smaller than the ${signaturesRequired} required signatures`,\n      );\n    }\n\n    // Make sure that all keys are normalized to the SingleKey authentication scheme\n    this.publicKeys = publicKeys.map((publicKey) =>\n      publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey),\n    );\n\n    this.signaturesRequired = signaturesRequired;\n  }\n\n  // endregion\n\n  // region AccountPublicKey\n\n  /**\n   * Verifies the provided signature against the given message.\n   * This function helps ensure the integrity and authenticity of the message by checking if the signature is valid.\n   *\n   * @param args - The arguments for verifying the signature.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify.\n   * @group Implementation\n   * @category Serialization\n   */\n  // eslint-disable-next-line class-methods-use-this, @typescript-eslint/no-unused-vars\n  verifySignature(args: VerifySignatureArgs): boolean {\n    throw new Error(\"not implemented\");\n  }\n\n  /**\n   * Generates an authentication key based on the current instance's byte representation.\n   * This key can be used for secure authentication processes within the system.\n   *\n   * @returns {AuthenticationKey} The generated authentication key.\n   * @group Implementation\n   * @category Serialization\n   */\n  authKey(): AuthenticationKey {\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: AuthenticationKeyScheme.MultiKey,\n      input: this.toUint8Array(),\n    });\n  }\n\n  // endregion\n\n  // region Serializable\n\n  /**\n   * Serializes the object by writing its signatures and bitmap to the provided serializer.\n   * This allows the object to be converted into a format suitable for transmission or storage.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @group Implementation\n   * @category Serialization\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeVector(this.publicKeys);\n    serializer.serializeU8(this.signaturesRequired);\n  }\n\n  /**\n   * Deserializes a MultiKeySignature from the provided deserializer.\n   * This function retrieves the signatures and bitmap necessary for creating a MultiKeySignature object.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @group Implementation\n   * @category Serialization\n   */\n  static deserialize(deserializer: Deserializer): MultiKey {\n    const keys = deserializer.deserializeVector(AnyPublicKey);\n    const signaturesRequired = deserializer.deserializeU8();\n\n    return new MultiKey({ publicKeys: keys, signaturesRequired });\n  }\n\n  // endregion\n\n  /**\n   * Get the index of the provided public key.\n   *\n   * This function retrieves the index of a specified public key within the MultiKey.\n   * If the public key does not exist, it throws an error.\n   *\n   * @param publicKey - The public key to find the index for.\n   * @returns The corresponding index of the public key, if it exists.\n   * @throws Error - If the public key is not found in the MultiKey.\n   * @group Implementation\n   */\n  getIndex(publicKey: PublicKey): number {\n    const anyPublicKey = publicKey instanceof AnyPublicKey ? publicKey : new AnyPublicKey(publicKey);\n    return super.getIndex(anyPublicKey);\n  }\n\n  public static isInstance(value: PublicKey): value is MultiKey {\n    return \"publicKeys\" in value && \"signaturesRequired\" in value;\n  }\n}\n\n/**\n * Represents a multi-signature transaction using Ed25519 signatures.\n * This class allows for the creation and management of a K-of-N multi-signature scheme,\n * where a specified number of signatures are required to authorize a transaction.\n *\n * It includes functionality to validate the number of signatures against a bitmap,\n * which indicates which public keys have signed the transaction.\n * @group Implementation\n * @category Serialization\n */\nexport class MultiKeySignature extends Signature {\n  /**\n   * Number of bytes in the bitmap representing who signed the transaction (32-bits)\n   * @group Implementation\n   * @category Serialization\n   */\n  static BITMAP_LEN: number = 4;\n\n  /**\n   * Maximum number of Ed25519 signatures supported\n   * @group Implementation\n   * @category Serialization\n   */\n  static MAX_SIGNATURES_SUPPORTED = MultiKeySignature.BITMAP_LEN * 8;\n\n  /**\n   * The list of underlying Ed25519 signatures\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly signatures: AnySignature[];\n\n  /**\n   * 32-bit Bitmap representing who signed the transaction\n   *\n   * This is represented where each public key can be masked to determine whether the message was signed by that key.\n   * @group Implementation\n   * @category Serialization\n   */\n  public readonly bitmap: Uint8Array;\n\n  /**\n   * Signature for a K-of-N multi-sig transaction.\n   *\n   * @see {@link\n   * https://aptos.dev/integration/creating-a-signed-transaction/#multisignature-transactions | Creating a Signed Transaction}\n   *\n   * @param args.signatures A list of signatures\n   * @param args.bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth\n   * signature should be provided in `signatures`. Bits are read from left to right\n   * @group Implementation\n   * @category Serialization\n   */\n  constructor(args: { signatures: Array<Signature | AnySignature>; bitmap: Uint8Array | number[] }) {\n    super();\n    const { signatures, bitmap } = args;\n\n    if (signatures.length > MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n      throw new Error(`The number of signatures cannot be greater than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED}`);\n    }\n\n    // Make sure that all signatures are normalized to the SingleKey authentication scheme\n    this.signatures = signatures.map((signature) =>\n      signature instanceof AnySignature ? signature : new AnySignature(signature),\n    );\n\n    if (!(bitmap instanceof Uint8Array)) {\n      this.bitmap = MultiKeySignature.createBitmap({ bits: bitmap });\n    } else if (bitmap.length !== MultiKeySignature.BITMAP_LEN) {\n      throw new Error(`\"bitmap\" length should be ${MultiKeySignature.BITMAP_LEN}`);\n    } else {\n      this.bitmap = bitmap;\n    }\n\n    const nSignatures = this.bitmap.reduce((acc, byte) => acc + bitCount(byte), 0);\n    if (nSignatures !== this.signatures.length) {\n      throw new Error(`Expecting ${nSignatures} signatures from the bitmap, but got ${this.signatures.length}`);\n    }\n  }\n\n  /**\n   * Helper method to create a bitmap out of the specified bit positions\n   * @param args.bits The bitmap positions that should be set. A position starts at index 0.\n   * Valid position should range between 0 and 31.\n   * @example\n   * Here's an example of valid `bits`\n   * ```\n   * [0, 2, 31]\n   * ```\n   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.\n   * The result bitmap should be 0b1010000000000000000000000000001\n   *\n   * @returns bitmap that is 32bit long\n   * @group Implementation\n   * @category Serialization\n   */\n  static createBitmap(args: { bits: number[] }): Uint8Array {\n    const { bits } = args;\n    // Bits are read from left to right. e.g. 0b10000000 represents the first bit is set in one byte.\n    // The decimal value of 0b10000000 is 128.\n    const firstBitInByte = 128;\n    const bitmap = new Uint8Array([0, 0, 0, 0]);\n\n    // Check if duplicates exist in bits\n    const dupCheckSet = new Set();\n\n    bits.forEach((bit: number) => {\n      if (bit >= MultiKeySignature.MAX_SIGNATURES_SUPPORTED) {\n        throw new Error(`Cannot have a signature larger than ${MultiKeySignature.MAX_SIGNATURES_SUPPORTED - 1}.`);\n      }\n\n      if (dupCheckSet.has(bit)) {\n        throw new Error(\"Duplicate bits detected.\");\n      }\n\n      dupCheckSet.add(bit);\n\n      const byteOffset = Math.floor(bit / 8);\n\n      let byte = bitmap[byteOffset];\n\n      // eslint-disable-next-line no-bitwise\n      byte |= firstBitInByte >> bit % 8;\n\n      bitmap[byteOffset] = byte;\n    });\n\n    return bitmap;\n  }\n\n  // region Serializable\n\n  serialize(serializer: Serializer): void {\n    // Note: we should not need to serialize the vector length, as it can be derived from the bitmap\n    serializer.serializeVector(this.signatures);\n    serializer.serializeBytes(this.bitmap);\n  }\n\n  static deserialize(deserializer: Deserializer): MultiKeySignature {\n    const signatures = deserializer.deserializeVector(AnySignature);\n    const bitmap = deserializer.deserializeBytes();\n    return new MultiKeySignature({ signatures, bitmap });\n  }\n\n  // endregion\n}\n"],"mappings":"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","names":["bitCount","byte","n","AbstractMultiKey","AccountPublicKey","args","bits","firstBitInByte","bitmap","dupCheckSet","bit","idx","byteOffset","publicKey","index","pk","MultiKey","_MultiKey","publicKeys","signaturesRequired","AnyPublicKey","AuthenticationKey","serializer","deserializer","keys","anyPublicKey","value","_MultiKeySignature","Signature","signatures","signature","AnySignature","nSignatures","acc","MultiKeySignature"]}