{"version":3,"sources":["../../src/account/AbstractKeylessAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport EventEmitter from \"eventemitter3\";\nimport { jwtDecode } from \"jwt-decode\";\nimport { EphemeralCertificateVariant, HexInput, SigningScheme } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  EphemeralCertificate,\n  ZeroKnowledgeSig,\n  ZkProof,\n  getKeylessJWKs,\n  MoveJWK,\n  getKeylessConfig,\n} from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Hex } from \"../core/hex\";\nimport { AccountAuthenticatorSingleKey } from \"../transactions/authenticator/account\";\nimport { Deserializer, Serializable, Serializer } from \"../bcs\";\nimport { deriveTransactionType, generateSigningMessage } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction, AnyRawTransactionInstance } from \"../transactions/types\";\nimport { base64UrlDecode } from \"../utils/helpers\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { Account } from \"./Account\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { KeylessError, KeylessErrorType } from \"../errors\";\nimport type { SingleKeySigner } from \"./SingleKeyAccount\";\n\n/**\n * An interface which defines if an Account utilizes Keyless signing.\n */\nexport interface KeylessSigner extends Account {\n  checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void>;\n}\n\nexport function isKeylessSigner(obj: any): obj is KeylessSigner {\n  return obj !== null && obj !== undefined && typeof obj.checkKeylessAccountValidity === \"function\";\n}\n\n/**\n * Account implementation for the Keyless authentication scheme.  This abstract class is used for standard Keyless Accounts\n * and Federated Keyless Accounts.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport abstract class AbstractKeylessAccount extends Serializable implements KeylessSigner, SingleKeySigner {\n  static readonly PEPPER_LENGTH: number = 31;\n\n  /**\n   * The KeylessPublicKey associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n\n  /**\n   * The EphemeralKeyPair used to generate sign.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly ephemeralKeyPair: EphemeralKeyPair;\n\n  /**\n   * The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly uidKey: string;\n\n  /**\n   * The value of the uidKey claim on the JWT.  This intended to be a stable user identifier.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly uidVal: string;\n\n  /**\n   * The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly aud: string;\n\n  /**\n   * A value contains 31 bytes of entropy that preserves privacy of the account. Typically fetched from a pepper provider.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly pepper: Uint8Array;\n\n  /**\n   * Account address associated with the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * The zero knowledge signature (if ready) which contains the proof used to validate the EphemeralKeyPair.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  proof: ZeroKnowledgeSig | undefined;\n\n  /**\n   * The proof of the EphemeralKeyPair or a promise that provides the proof.  This is used to allow for awaiting on\n   * fetching the proof.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly proofOrPromise: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n\n  /**\n   * Signing scheme used to sign transactions\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signingScheme: SigningScheme = SigningScheme.SingleKey;\n\n  /**\n   * The JWT token used to derive the account\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly jwt: string;\n\n  /**\n   * The hash of the verification key used to verify the proof. This is optional and can be used to check verifying key\n   * rotations which may invalidate the proof.\n   */\n  readonly verificationKeyHash?: Uint8Array;\n\n  /**\n   * An event emitter used to assist in handling asynchronous proof fetching.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  private readonly emitter: EventEmitter<ProofFetchEvents>;\n\n  /**\n   * Use the static generator `create(...)` instead.\n   * Creates an instance of the KeylessAccount with an optional proof.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.publicKey - A KeylessPublicKey or FederatedKeylessPublicKey.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.iss - A JWT issuer.\n   * @param args.uidKey - The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   * @param args.uidVal - The unique id for this user, intended to be a stable user identifier.\n   * @param args.aud - The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.verificationKeyHash Optional 32-byte verification key hash as hex input used to check proof validity.\n   */\n  protected constructor(args: {\n    address?: AccountAddress;\n    publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n    verificationKeyHash?: HexInput;\n  }) {\n    super();\n    const {\n      address,\n      ephemeralKeyPair,\n      publicKey,\n      uidKey,\n      uidVal,\n      aud,\n      pepper,\n      proof,\n      proofFetchCallback,\n      jwt,\n      verificationKeyHash,\n    } = args;\n    this.ephemeralKeyPair = ephemeralKeyPair;\n    this.publicKey = publicKey;\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n    this.uidKey = uidKey;\n    this.uidVal = uidVal;\n    this.aud = aud;\n    this.jwt = jwt;\n    this.emitter = new EventEmitter<ProofFetchEvents>();\n    this.proofOrPromise = proof;\n    if (proof instanceof ZeroKnowledgeSig) {\n      this.proof = proof;\n    } else {\n      if (proofFetchCallback === undefined) {\n        throw new Error(\"Must provide callback for async proof fetch\");\n      }\n      this.emitter.on(\"proofFetchFinish\", async (status) => {\n        await proofFetchCallback(status);\n        this.emitter.removeAllListeners();\n      });\n      // Note, this is purposely not awaited to be non-blocking.  The caller should await on the proofFetchCallback.\n      this.init(proof);\n    }\n    const pepperBytes = Hex.fromHexInput(pepper).toUint8Array();\n    if (pepperBytes.length !== AbstractKeylessAccount.PEPPER_LENGTH) {\n      throw new Error(`Pepper length in bytes should be ${AbstractKeylessAccount.PEPPER_LENGTH}`);\n    }\n    this.pepper = pepperBytes;\n    if (verificationKeyHash !== undefined) {\n      if (Hex.hexInputToUint8Array(verificationKeyHash).length !== 32) {\n        throw new Error(\"verificationKeyHash must be 32 bytes\");\n      }\n      this.verificationKeyHash = Hex.hexInputToUint8Array(verificationKeyHash);\n    }\n  }\n\n  getAnyPublicKey(): AnyPublicKey {\n    return new AnyPublicKey(this.publicKey);\n  }\n\n  /**\n   * This initializes the asynchronous proof fetch\n   * @return Emits whether the proof succeeds or fails, but has no return.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async init(promise: Promise<ZeroKnowledgeSig>) {\n    try {\n      this.proof = await promise;\n      this.emitter.emit(\"proofFetchFinish\", { status: \"Success\" });\n    } catch (error) {\n      if (error instanceof Error) {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: error.toString() });\n      } else {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: \"Unknown\" });\n      }\n    }\n  }\n\n  /**\n   * Serializes the jwt data into a format suitable for transmission or storage.\n   * This function ensures that both the jwt data and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the jwt data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    this.accountAddress.serialize(serializer);\n    serializer.serializeStr(this.jwt);\n    serializer.serializeStr(this.uidKey);\n    serializer.serializeFixedBytes(this.pepper);\n    this.ephemeralKeyPair.serialize(serializer);\n    if (this.proof === undefined) {\n      throw new Error(\"Cannot serialize - proof undefined\");\n    }\n    this.proof.serialize(serializer);\n    serializer.serializeOption(this.verificationKeyHash, 32);\n  }\n\n  static partialDeserialize(deserializer: Deserializer): {\n    address: AccountAddress;\n    jwt: string;\n    uidKey: string;\n    pepper: Uint8Array;\n    ephemeralKeyPair: EphemeralKeyPair;\n    proof: ZeroKnowledgeSig;\n    verificationKeyHash?: Uint8Array;\n  } {\n    const address = AccountAddress.deserialize(deserializer);\n    const jwt = deserializer.deserializeStr();\n    const uidKey = deserializer.deserializeStr();\n    const pepper = deserializer.deserializeFixedBytes(31);\n    const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n    const proof = ZeroKnowledgeSig.deserialize(deserializer);\n    const verificationKeyHash = deserializer.deserializeOption(\"fixedBytes\", 32);\n\n    return { address, jwt, uidKey, pepper, ephemeralKeyPair, proof, verificationKeyHash };\n  }\n\n  /**\n   * Checks if the proof is expired.  If so the account must be re-derived with a new EphemeralKeyPair\n   * and JWT token.\n   * @return boolean\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  isExpired(): boolean {\n    return this.ephemeralKeyPair.isExpired();\n  }\n\n  /**\n   * Sign a message using Keyless.\n   * @param message the message to sign, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.sign(message));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Sign a transaction using Keyless.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.signTransaction(transaction));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Waits for asynchronous proof fetching to finish.\n   * @return\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  async waitForProofFetch() {\n    if (this.proofOrPromise instanceof Promise) {\n      await this.proofOrPromise;\n    }\n  }\n\n  /**\n   * Validates that the Keyless Account can be used to sign transactions.\n   * @return\n   */\n  async checkKeylessAccountValidity(aptosConfig: AptosConfig): Promise<void> {\n    if (this.isExpired()) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED,\n      });\n    }\n    await this.waitForProofFetch();\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.ASYNC_PROOF_FETCH_FAILED,\n      });\n    }\n    const header = jwtDecode(this.jwt, { header: true });\n    if (header.kid === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.JWT_PARSING_ERROR,\n        details: \"checkKeylessAccountValidity failed. JWT is missing 'kid' in header. This should never happen.\",\n      });\n    }\n    if (this.verificationKeyHash !== undefined) {\n      const { verificationKey } = await getKeylessConfig({ aptosConfig });\n      if (Hex.hexInputToString(verificationKey.hash()) !== Hex.hexInputToString(this.verificationKeyHash)) {\n        throw KeylessError.fromErrorType({\n          type: KeylessErrorType.INVALID_PROOF_VERIFICATION_KEY_NOT_FOUND,\n        });\n      }\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"[Aptos SDK] The verification key hash was not set. Proof may be invalid if the verification key has rotated.\",\n      );\n    }\n    await AbstractKeylessAccount.fetchJWK({ aptosConfig, publicKey: this.publicKey, kid: header.kid });\n  }\n\n  /**\n   * Sign the given message using Keyless.\n   * @param message in HexInput format\n   * @returns Signature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  sign(message: HexInput): KeylessSignature {\n    const { expiryDateSecs } = this.ephemeralKeyPair;\n    if (this.isExpired()) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.EPHEMERAL_KEY_PAIR_EXPIRED,\n      });\n    }\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const ephemeralPublicKey = this.ephemeralKeyPair.getPublicKey();\n    const ephemeralSignature = this.ephemeralKeyPair.sign(message);\n\n    return new KeylessSignature({\n      jwtHeader: base64UrlDecode(this.jwt.split(\".\")[0]),\n      ephemeralCertificate: new EphemeralCertificate(this.proof, EphemeralCertificateVariant.ZkProof),\n      expiryDateSecs,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  /**\n   * Sign the given transaction with Keyless.\n   * Signs the transaction and proof to guard against proof malleability.\n   * @param transaction the transaction to be signed\n   * @returns KeylessSignature\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  signTransaction(transaction: AnyRawTransaction): KeylessSignature {\n    if (this.proof === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.PROOF_NOT_FOUND,\n        details: \"Proof not found - make sure to call `await account.checkKeylessAccountValidity()` before signing.\",\n      });\n    }\n    const raw = deriveTransactionType(transaction);\n    const txnAndProof = new TransactionAndProof(raw, this.proof.proof);\n    const signMess = txnAndProof.hash();\n    return this.sign(signMess);\n  }\n\n  /**\n   * Note - This function is currently incomplete and should only be used to verify ownership of the KeylessAccount\n   *\n   * Verifies a signature given the message.\n   *\n   * TODO: Groth16 proof verification\n   *\n   * @param args.message the message that was signed.\n   * @param args.signature the KeylessSignature to verify\n   * @returns boolean\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  verifySignature(args: { message: HexInput; signature: KeylessSignature }): boolean {\n    const { message, signature } = args;\n    if (this.isExpired()) {\n      return false;\n    }\n    if (!this.ephemeralKeyPair.getPublicKey().verifySignature({ message, signature: signature.ephemeralSignature })) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Fetches the JWK from the issuer's well-known JWKS endpoint.\n   *\n   * @param args.publicKey The keyless public key to query\n   * @param args.kid The kid of the JWK to fetch\n   * @returns A JWK matching the `kid` in the JWT header.\n   * @throws {KeylessError} If the JWK cannot be fetched\n   */\n  static async fetchJWK(args: {\n    aptosConfig: AptosConfig;\n    publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n    kid: string;\n  }): Promise<MoveJWK> {\n    const { aptosConfig, publicKey, kid } = args;\n    const keylessPubKey = publicKey instanceof KeylessPublicKey ? publicKey : publicKey.keylessPublicKey;\n    const { iss } = keylessPubKey;\n\n    let allJWKs: Map<string, MoveJWK[]>;\n    const jwkAddr = publicKey instanceof FederatedKeylessPublicKey ? publicKey.jwkAddress : undefined;\n    try {\n      allJWKs = await getKeylessJWKs({ aptosConfig, jwkAddr });\n    } catch (error) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.FULL_NODE_JWKS_LOOKUP_ERROR,\n        error,\n        details: `Failed to fetch ${jwkAddr ? \"Federated\" : \"Patched\"}JWKs ${jwkAddr ? `for address ${jwkAddr}` : \"0x1\"}`,\n      });\n    }\n\n    // Find the corresponding JWK set by `iss`\n    const jwksForIssuer = allJWKs.get(iss);\n\n    if (jwksForIssuer === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.INVALID_JWT_ISS_NOT_RECOGNIZED,\n        details: `JWKs for issuer ${iss} not found.`,\n      });\n    }\n\n    // Find the corresponding JWK by `kid`\n    const jwk = jwksForIssuer.find((key) => key.kid === kid);\n\n    if (jwk === undefined) {\n      throw KeylessError.fromErrorType({\n        type: KeylessErrorType.INVALID_JWT_JWK_NOT_FOUND,\n        details: `JWK with kid '${kid}' for issuer '${iss}' not found.`,\n      });\n    }\n\n    return jwk;\n  }\n}\n\n/**\n * A container class to hold a transaction and a proof.  It implements CryptoHashable which is used to create\n * the signing message for Keyless transactions.  We sign over the proof to ensure non-malleability.\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport class TransactionAndProof extends Serializable {\n  /**\n   * The transaction to sign.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  transaction: AnyRawTransactionInstance;\n\n  /**\n   * The zero knowledge proof used in signing the transaction.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  proof?: ZkProof;\n\n  /**\n   * The domain separator prefix used when hashing.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly domainSeparator = \"APTOS::TransactionAndProof\";\n\n  constructor(transaction: AnyRawTransactionInstance, proof?: ZkProof) {\n    super();\n    this.transaction = transaction;\n    this.proof = proof;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.transaction.bcsToBytes());\n    serializer.serializeOption(this.proof);\n  }\n\n  /**\n   * Hashes the bcs serialized from of the class. This is the typescript corollary to the BCSCryptoHash macro in aptos-core.\n   *\n   * @returns Uint8Array\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  hash(): Uint8Array {\n    return generateSigningMessage(this.bcsToBytes(), this.domainSeparator);\n  }\n}\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchSuccess = {\n  status: \"Success\";\n};\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchFailure = {\n  status: \"Failed\";\n  error: string;\n};\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchStatus = ProofFetchSuccess | ProofFetchFailure;\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport type ProofFetchCallback = (status: ProofFetchStatus) => Promise<void>;\n/**\n * @group Implementation\n * @category Account (On-Chain Model)\n */\nexport interface ProofFetchEvents {\n  proofFetchFinish: (status: ProofFetchStatus) => void;\n}\n"],"mappings":"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","names":["EventEmitter","jwtDecode","isKeylessSigner","obj","_AbstractKeylessAccount","Serializable","args","address","ephemeralKeyPair","publicKey","uidKey","uidVal","aud","pepper","proof","proofFetchCallback","jwt","verificationKeyHash","AccountAddress","EventEmitter","ZeroKnowledgeSig","status","pepperBytes","Hex","AnyPublicKey","promise","error","serializer","deserializer","EphemeralKeyPair","message","signature","AnySignature","AccountAuthenticatorSingleKey","transaction","aptosConfig","KeylessError","header","jwtDecode","verificationKey","getKeylessConfig","expiryDateSecs","ephemeralPublicKey","ephemeralSignature","KeylessSignature","base64UrlDecode","EphemeralCertificate","raw","deriveTransactionType","signMess","TransactionAndProof","kid","keylessPubKey","KeylessPublicKey","iss","allJWKs","jwkAddr","FederatedKeylessPublicKey","getKeylessJWKs","jwksForIssuer","jwk","key","AbstractKeylessAccount","generateSigningMessage"]}