{"version":3,"sources":["../../src/account/AbstractedAccount.ts"],"sourcesContent":["import { sha3_256 } from \"@noble/hashes/sha3\";\nimport { AccountAddress } from \"../core\";\nimport { AbstractPublicKey, AbstractSignature } from \"../core/crypto/abstraction\";\nimport { SigningScheme, HexInput } from \"../types\";\nimport { Account } from \"./Account\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AccountAuthenticatorAbstraction } from \"../transactions/authenticator/account\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { Serializer } from \"../bcs/serializer\";\nimport { isValidFunctionInfo } from \"../utils/helpers\";\n\ntype AbstractedAccountConstructorArgs = {\n  /**\n   * The account address of the account.\n   */\n  accountAddress: AccountAddress;\n  /**\n   * The signer function signs transactions and returns the `authenticator` bytes in the `AbstractionAuthData`.\n   *\n   * @param digest - The SHA256 hash of the transaction signing message\n   * @returns The `authenticator` bytes that can be used to verify the signature.\n   */\n  signer: (digest: HexInput) => HexInput;\n  /**\n   * The authentication function that will be used to verify the signature.\n   *\n   * @example\n   * ```ts\n   * const authenticationFunction = `${accountAddress}::permissioned_delegation::authenticate`;\n   * ```\n   */\n  authenticationFunction: string;\n};\n\nexport class AbstractedAccount extends Account {\n  public readonly publicKey: AbstractPublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly authenticationFunction: string;\n\n  readonly signingScheme = SigningScheme.SingleKey;\n\n  constructor({ signer, accountAddress, authenticationFunction }: AbstractedAccountConstructorArgs) {\n    super();\n\n    if (!isValidFunctionInfo(authenticationFunction)) {\n      throw new Error(`Invalid authentication function ${authenticationFunction} passed into AbstractedAccount`);\n    }\n\n    this.authenticationFunction = authenticationFunction;\n    this.accountAddress = accountAddress;\n    this.publicKey = new AbstractPublicKey(this.accountAddress);\n    this.sign = (digest: HexInput) => new AbstractSignature(signer(digest));\n  }\n\n  /**\n   * Creates an `AbstractedAccount` from an `Ed25519Account` that has a permissioned signer function and\n   * using the `0x1::permissioned_delegation::authenticate` function to verify the signature.\n   *\n   * @param signer - The `Ed25519Account` that can be used to sign permissioned transactions.\n   * @returns The `AbstractedAccount`\n   */\n  public static fromPermissionedSigner({\n    signer,\n    accountAddress,\n  }: {\n    signer: Ed25519Account;\n    accountAddress?: AccountAddress;\n  }) {\n    return new AbstractedAccount({\n      signer: (digest: HexInput) => {\n        const serializer = new Serializer();\n        signer.publicKey.serialize(serializer);\n        signer.sign(digest).serialize(serializer);\n        return serializer.toUint8Array();\n      },\n      accountAddress: accountAddress ?? signer.accountAddress,\n      authenticationFunction: \"0x1::permissioned_delegation::authenticate\",\n    });\n  }\n\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorAbstraction {\n    return new AccountAuthenticatorAbstraction(\n      this.authenticationFunction,\n      sha3_256(message),\n      this.sign(sha3_256(message)).toUint8Array(),\n    );\n  }\n\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorAbstraction {\n    return this.signWithAuthenticator(generateSigningMessageForTransaction(transaction));\n  }\n\n  sign: (message: HexInput) => AbstractSignature;\n\n  signTransaction(transaction: AnyRawTransaction): AbstractSignature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  /**\n   * Update the signer function for the account. This can be done after asynchronous operations are complete\n   * to update the context of the signer function.\n   *\n   * @param signer - The new signer function to use for the account.\n   */\n  public setSigner(signer: (digest: HexInput) => HexInput): void {\n    this.sign = (digest: HexInput) => new AbstractSignature(signer(digest));\n  }\n}\n"],"mappings":"6PAAA,OAAS,YAAAA,MAAgB,qBAmClB,IAAMC,EAAN,MAAMC,UAA0BC,CAAQ,CAS7C,YAAY,CAAE,OAAAC,EAAQ,eAAAC,EAAgB,uBAAAC,CAAuB,EAAqC,CAChG,MAAM,EAHR,KAAS,cAAgB,EAKnB,IAACC,EAAoBD,CAAsB,EAC7C,MAAM,IAAI,MAAM,mCAAmCA,CAAsB,gCAAgC,EAG3G,KAAK,uBAAyBA,EAC9B,KAAK,eAAiBD,EACtB,KAAK,UAAY,IAAIG,EAAkB,KAAK,cAAc,EAC1D,KAAK,KAAQC,GAAqB,IAAIC,EAAkBN,EAAOK,CAAM,CAAC,CACxE,CASA,OAAc,uBAAuB,CACnC,OAAAL,EACA,eAAAC,CACF,EAGG,CACD,OAAO,IAAIH,EAAkB,CAC3B,OAASO,GAAqB,CAC5B,IAAME,EAAa,IAAIC,EACvB,OAAAR,EAAO,UAAU,UAAUO,CAAU,EACrCP,EAAO,KAAKK,CAAM,EAAE,UAAUE,CAAU,EACjCA,EAAW,aAAa,CACjC,EACA,eAAgBN,GAAkBD,EAAO,eACzC,uBAAwB,4CAC1B,CAAC,CACH,CAEA,sBAAsBS,EAAoD,CACxE,OAAO,IAAIC,EACT,KAAK,uBACLC,EAASF,CAAO,EAChB,KAAK,KAAKE,EAASF,CAAO,CAAC,EAAE,aAAa,CAC5C,CACF,CAEA,iCAAiCG,EAAiE,CAChG,OAAO,KAAK,sBAAsBC,EAAqCD,CAAW,CAAC,CACrF,CAIA,gBAAgBA,EAAmD,CACjE,OAAO,KAAK,KAAKC,EAAqCD,CAAW,CAAC,CACpE,CAQO,UAAUZ,EAA8C,CAC7D,KAAK,KAAQK,GAAqB,IAAIC,EAAkBN,EAAOK,CAAM,CAAC,CACxE,CACF","names":["sha3_256","AbstractedAccount","_AbstractedAccount","Account","signer","accountAddress","authenticationFunction","isValidFunctionInfo","AbstractPublicKey","digest","AbstractSignature","serializer","Serializer","message","AccountAuthenticatorAbstraction","sha3_256","transaction","generateSigningMessageForTransaction"]}