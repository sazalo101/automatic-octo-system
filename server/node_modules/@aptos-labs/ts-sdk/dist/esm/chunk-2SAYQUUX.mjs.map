{"version":3,"sources":["../../src/account/MultiEd25519Account.ts"],"sourcesContent":["import { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { Ed25519PrivateKey } from \"../core/crypto\";\nimport { MultiEd25519PublicKey, MultiEd25519Signature } from \"../core/crypto/multiEd25519\";\nimport { AccountAuthenticatorMultiEd25519 } from \"../transactions/authenticator/account\";\nimport { generateSigningMessageForTransaction } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction } from \"../transactions/types\";\nimport { HexInput, SigningScheme } from \"../types\";\nimport type { Account } from \"./Account\";\n\nexport interface MultiEd25519SignerConstructorArgs {\n  publicKey: MultiEd25519PublicKey;\n  signers: Ed25519PrivateKey[];\n  address?: AccountAddressInput;\n}\n\nexport interface VerifyMultiEd25519SignatureArgs {\n  message: HexInput;\n  signature: MultiEd25519Signature;\n}\n\n/**\n * Signer implementation for the Multi-Ed25519 authentication scheme.\n *\n * Note: This authentication scheme is a legacy authentication scheme.  Prefer using MultiKeyAccounts as a\n * MultiKeyAccount can support any type of signer, not just Ed25519.  Generating a signer instance does not\n * create the account on-chain.\n */\nexport class MultiEd25519Account implements Account {\n  readonly publicKey: MultiEd25519PublicKey;\n\n  readonly accountAddress: AccountAddress;\n\n  readonly signingScheme = SigningScheme.MultiEd25519;\n\n  /**\n   * The signers used to sign messages.  These signers should correspond to public keys in the\n   * MultiEd25519Account.  The number of signers should be equal to this.publicKey.threshold.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signers: Ed25519PrivateKey[];\n\n  /**\n   * An array of indices where for signer[i], signerIndicies[i] is the index of the corresponding public key in\n   * publicKey.publicKeys.  Used to derive the right public key to use for verification.\n   * @group Implementation\n   * @category Account (On-Chain Model)\n   */\n  readonly signerIndices: number[];\n\n  readonly signaturesBitmap: Uint8Array;\n\n  // region Constructors\n\n  constructor(args: MultiEd25519SignerConstructorArgs) {\n    const { signers, publicKey, address } = args;\n    this.publicKey = publicKey;\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n\n    if (publicKey.threshold > signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `Not enough signers provided to satisfy the required signatures. Need ${publicKey.threshold} signers, but only ${signers.length} provided`,\n      );\n    } else if (publicKey.threshold < signers.length) {\n      throw new Error(\n        // eslint-disable-next-line max-len\n        `More signers provided than required. Need ${publicKey.threshold} signers, but ${signers.length} provided`,\n      );\n    }\n\n    // For each signer, find its corresponding position in the public keys array\n    const bitPositions: number[] = [];\n    for (const signer of signers) {\n      bitPositions.push(this.publicKey.getIndex(signer.publicKey()));\n    }\n\n    // Create pairs of [signer, position] and sort them by position\n    // This sorting is critical because:\n    // 1. The on-chain verification expects signatures to be in ascending order by bit position\n    // 2. The bitmap must match the order of signatures when verifying\n    const signersAndBitPosition: [Ed25519PrivateKey, number][] = signers.map((signer, index) => [\n      signer,\n      bitPositions[index],\n    ]);\n    signersAndBitPosition.sort((a, b) => a[1] - b[1]);\n\n    // Extract the sorted signers and their positions into separate arrays\n    this.signers = signersAndBitPosition.map((value) => value[0]);\n    this.signerIndices = signersAndBitPosition.map((value) => value[1]);\n\n    // Create a bitmap representing which public keys from the MultiEd25519PublicKey are being used\n    // This bitmap is used during signature verification to identify which public keys\n    // should be used to verify each signature\n    this.signaturesBitmap = this.publicKey.createBitmap({ bits: bitPositions });\n  }\n\n  // endregion\n\n  // region Account\n\n  /**\n   * Verify the given message and signature with the public key.\n   *\n   * @param args.message raw message data in HexInput format\n   * @param args.signature signed message Signature\n   * @returns\n   */\n  verifySignature(args: VerifyMultiEd25519SignatureArgs): boolean {\n    return this.publicKey.verifySignature(args);\n  }\n\n  /**\n   * Sign a message using the account's Ed25519 private key.\n   * @param message the signing message, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorMultiEd25519 {\n    return new AccountAuthenticatorMultiEd25519(this.publicKey, this.sign(message));\n  }\n\n  /**\n   * Sign a transaction using the account's Ed25519 private keys.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorMultiEd25519 {\n    return new AccountAuthenticatorMultiEd25519(this.publicKey, this.signTransaction(transaction));\n  }\n\n  /**\n   * Sign the given message using the account's Ed25519 private keys.\n   * @param message in HexInput format\n   * @returns MultiEd25519Signature\n   */\n  sign(message: HexInput): MultiEd25519Signature {\n    const signatures = [];\n    for (const signer of this.signers) {\n      signatures.push(signer.sign(message));\n    }\n    return new MultiEd25519Signature({ signatures, bitmap: this.signaturesBitmap });\n  }\n\n  /**\n   * Sign the given transaction using the available signing capabilities.\n   * @param transaction the transaction to be signed\n   * @returns Signature\n   */\n  signTransaction(transaction: AnyRawTransaction): MultiEd25519Signature {\n    return this.sign(generateSigningMessageForTransaction(transaction));\n  }\n\n  // endregion\n}\n"],"mappings":"oKA2BO,IAAMA,EAAN,KAA6C,CA2BlD,YAAYC,EAAyC,CAtBrD,KAAS,cAAgB,EAuBvB,GAAM,CAAE,QAAAC,EAAS,UAAAC,EAAW,QAAAC,CAAQ,EAAIH,EAIxC,GAHA,KAAK,UAAYE,EACjB,KAAK,eAAiBC,EAAUC,EAAe,KAAKD,CAAO,EAAI,KAAK,UAAU,QAAQ,EAAE,eAAe,EAEnGD,EAAU,UAAYD,EAAQ,OAChC,MAAM,IAAI,MAER,wEAAwEC,EAAU,SAAS,sBAAsBD,EAAQ,MAAM,WACjI,EACK,GAAIC,EAAU,UAAYD,EAAQ,OACvC,MAAM,IAAI,MAER,6CAA6CC,EAAU,SAAS,iBAAiBD,EAAQ,MAAM,WACjG,EAIF,IAAMI,EAAyB,CAAC,EAChC,QAAWC,KAAUL,EACnBI,EAAa,KAAK,KAAK,UAAU,SAASC,EAAO,UAAU,CAAC,CAAC,EAO/D,IAAMC,EAAuDN,EAAQ,IAAI,CAACK,EAAQE,IAAU,CAC1FF,EACAD,EAAaG,CAAK,CACpB,CAAC,EACDD,EAAsB,KAAK,CAACE,EAAGC,IAAMD,EAAE,CAAC,EAAIC,EAAE,CAAC,CAAC,EAGhD,KAAK,QAAUH,EAAsB,IAAKI,GAAUA,EAAM,CAAC,CAAC,EAC5D,KAAK,cAAgBJ,EAAsB,IAAKI,GAAUA,EAAM,CAAC,CAAC,EAKlE,KAAK,iBAAmB,KAAK,UAAU,aAAa,CAAE,KAAMN,CAAa,CAAC,CAC5E,CAaA,gBAAgBL,EAAgD,CAC9D,OAAO,KAAK,UAAU,gBAAgBA,CAAI,CAC5C,CAOA,sBAAsBY,EAAqD,CACzE,OAAO,IAAIC,EAAiC,KAAK,UAAW,KAAK,KAAKD,CAAO,CAAC,CAChF,CAOA,iCAAiCE,EAAkE,CACjG,OAAO,IAAID,EAAiC,KAAK,UAAW,KAAK,gBAAgBC,CAAW,CAAC,CAC/F,CAOA,KAAKF,EAA0C,CAC7C,IAAMG,EAAa,CAAC,EACpB,QAAWT,KAAU,KAAK,QACxBS,EAAW,KAAKT,EAAO,KAAKM,CAAO,CAAC,EAEtC,OAAO,IAAII,EAAsB,CAAE,WAAAD,EAAY,OAAQ,KAAK,gBAAiB,CAAC,CAChF,CAOA,gBAAgBD,EAAuD,CACrE,OAAO,KAAK,KAAKG,EAAqCH,CAAW,CAAC,CACpE,CAGF","names":["MultiEd25519Account","args","signers","publicKey","address","AccountAddress","bitPositions","signer","signersAndBitPosition","index","a","b","value","message","AccountAuthenticatorMultiEd25519","transaction","signatures","MultiEd25519Signature","generateSigningMessageForTransaction"]}