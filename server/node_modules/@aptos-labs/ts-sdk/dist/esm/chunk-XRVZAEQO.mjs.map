{"version":3,"sources":["../../src/transactions/transactionBuilder/remoteAbi.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { parseTypeTag } from \"../typeTag/parser\";\nimport {\n  TypeTag,\n  TypeTagAddress,\n  TypeTagBool,\n  TypeTagStruct,\n  TypeTagU128,\n  TypeTagU16,\n  TypeTagU256,\n  TypeTagU32,\n  TypeTagU64,\n  TypeTagU8,\n} from \"../typeTag\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport {\n  EntryFunctionArgumentTypes,\n  SimpleEntryFunctionArgumentTypes,\n  EntryFunctionABI,\n  ViewFunctionABI,\n  FunctionABI,\n  TypeArgument,\n} from \"../types\";\nimport { Bool, MoveOption, MoveString, MoveVector, U128, U16, U256, U32, U64, U8 } from \"../../bcs\";\nimport { AccountAddress } from \"../../core\";\nimport { getModule } from \"../../internal/account\";\nimport {\n  findFirstNonSignerArg,\n  isBcsAddress,\n  isBcsBool,\n  isBcsString,\n  isBcsU128,\n  isBcsU16,\n  isBcsU256,\n  isBcsU32,\n  isBcsU64,\n  isBcsU8,\n  isBool,\n  isEncodedEntryFunctionArgument,\n  isLargeNumber,\n  isEmptyOption,\n  isString,\n  throwTypeMismatch,\n  convertNumber,\n} from \"./helpers\";\nimport { CallArgument, MoveFunction } from \"../../types\";\n\nconst TEXT_ENCODER = new TextEncoder();\n\n/**\n * Convert type arguments to only type tags, allowing for string representations of type tags.\n *\n * @param typeArguments - An optional array of type arguments that may include string representations.\n * @returns An array of TypeTag objects derived from the provided type arguments.\n * @group Implementation\n * @category Transactions\n */\nexport function standardizeTypeTags(typeArguments?: Array<TypeArgument>): Array<TypeTag> {\n  return (\n    typeArguments?.map((typeArg: TypeArgument): TypeTag => {\n      // Convert to TypeTag if it's a string representation\n      if (isString(typeArg)) {\n        return parseTypeTag(typeArg);\n      }\n      return typeArg;\n    }) ?? []\n  );\n}\n\n/**\n * Fetches the ABI of a specified function from the on-chain module ABI. This function allows you to access the details of a\n * specific function within a module.\n *\n * @param moduleAddress - The address of the module from which to fetch the function ABI.\n * @param moduleName - The name of the module containing the function.\n * @param functionName - The name of the function whose ABI is to be fetched.\n * @param aptosConfig - The configuration settings for Aptos.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<MoveFunction | undefined> {\n  // This fetch from the API is currently cached\n  const module = await getModule({ aptosConfig, accountAddress: moduleAddress, moduleName });\n\n  if (module.abi) {\n    return module.abi.exposed_functions.find((func) => func.name === functionName);\n  }\n\n  return undefined;\n}\n\n/**\n * Fetches a function ABI from the on-chain module ABI.  It doesn't validate whether it's a view or entry function.\n * @param moduleAddress\n * @param moduleName\n * @param functionName\n * @param aptosConfig\n */\nexport async function fetchMoveFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<FunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n  if (!functionAbi) {\n    throw new Error(`Could not find function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for an entry function from the specified module address.\n * This function validates if the ABI corresponds to an entry function and retrieves its parameters.\n *\n * @param moduleAddress - The address of the module containing the entry function.\n * @param moduleName - The name of the module containing the entry function.\n * @param functionName - The name of the entry function to fetch the ABI for.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the number of signers, type parameters, and function parameters.\n * @throws Error if the ABI cannot be found or if the function is not an entry function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchEntryFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<EntryFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find entry function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-entry functions also can't be used\n  if (!functionAbi.is_entry) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an entry function`);\n  }\n\n  // Remove the signer arguments\n  const numSigners = findFirstNonSignerArg(functionAbi);\n  const params: TypeTag[] = [];\n  for (let i = numSigners; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  return {\n    signers: numSigners,\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n  };\n}\n\n/**\n * Fetches the ABI for a view function from the specified module address.\n * This function ensures that the ABI is valid and retrieves the type parameters, parameters, and return types for the view function.\n *\n * @param moduleAddress - The address of the module containing the view function.\n * @param moduleName - The name of the module containing the view function.\n * @param functionName - The name of the view function for which to fetch the ABI.\n * @param aptosConfig - The configuration settings for Aptos.\n * @returns An object containing the type parameters, parameters, and return types of the view function.\n * @throws Error if the ABI cannot be found or if the function is not a view function.\n * @group Implementation\n * @category Transactions\n */\nexport async function fetchViewFunctionAbi(\n  moduleAddress: string,\n  moduleName: string,\n  functionName: string,\n  aptosConfig: AptosConfig,\n): Promise<ViewFunctionABI> {\n  const functionAbi = await fetchFunctionAbi(moduleAddress, moduleName, functionName, aptosConfig);\n\n  // If there's no ABI, then the function is invalid\n  if (!functionAbi) {\n    throw new Error(`Could not find view function ABI for '${moduleAddress}::${moduleName}::${functionName}'`);\n  }\n\n  // Non-view functions can't be used\n  if (!functionAbi.is_view) {\n    throw new Error(`'${moduleAddress}::${moduleName}::${functionName}' is not an view function`);\n  }\n\n  // Type tag parameters for the function\n  const params: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.params.length; i += 1) {\n    params.push(parseTypeTag(functionAbi.params[i], { allowGenerics: true }));\n  }\n\n  // The return types of the view function\n  const returnTypes: TypeTag[] = [];\n  for (let i = 0; i < functionAbi.return.length; i += 1) {\n    returnTypes.push(parseTypeTag(functionAbi.return[i], { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters: functionAbi.generic_type_params,\n    parameters: params,\n    returnTypes,\n  };\n}\n\n/**\n * Converts a entry function argument into CallArgument, if necessary.\n * This function checks the provided argument against the expected parameter type and converts it accordingly.\n *\n * @param functionName - The name of the function for which the argument is being converted.\n * @param functionAbi - The ABI (Application Binary Interface) of the function, which defines its parameters.\n * @param argument - The argument to be converted, which can be of various types. If the argument is already\n *                   CallArgument returned from TransactionComposer it would be returned immediately.\n * @param position - The index of the argument in the function's parameter list.\n * @param genericTypeParams - An array of type tags for any generic type parameters.\n */\nexport function convertCallArgument(\n  argument: CallArgument | EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  functionName: string,\n  functionAbi: FunctionABI,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): CallArgument {\n  if (argument instanceof CallArgument) {\n    return argument;\n  }\n  return CallArgument.newBytes(\n    convertArgument(functionName, functionAbi, argument, position, genericTypeParams).bcsToBytes(),\n  );\n}\n\n/**\n * Converts a non-BCS encoded argument into BCS encoded, if necessary.\n * This function checks the provided argument against the expected parameter type and converts it accordingly.\n *\n * @param functionName - The name of the function for which the argument is being converted.\n * @param functionAbi - The ABI (Application Binary Interface) of the function, which defines its parameters.\n * @param arg - The argument to be converted, which can be of various types.\n * @param position - The index of the argument in the function's parameter list.\n * @param genericTypeParams - An array of type tags for any generic type parameters.\n * @group Implementation\n * @category Transactions\n */\nexport function convertArgument(\n  functionName: string,\n  functionAbi: FunctionABI,\n  arg: EntryFunctionArgumentTypes | SimpleEntryFunctionArgumentTypes,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // Ensure not too many arguments\n  if (position >= functionAbi.parameters.length) {\n    throw new Error(`Too many arguments for '${functionName}', expected ${functionAbi.parameters.length}`);\n  }\n\n  const param = functionAbi.parameters[position];\n  return checkOrConvertArgument(arg, param, position, genericTypeParams);\n}\n\n/**\n * Checks if the provided argument is BCS encoded and converts it if necessary, ensuring type compatibility with the ABI.\n * This function helps in validating and converting arguments for entry functions based on their expected types.\n *\n * @param arg - The argument to check or convert, which can be either a simple or entry function argument type.\n * @param param - The expected type tag for the argument.\n * @param position - The position of the argument in the function call.\n * @param genericTypeParams - An array of generic type parameters that may be used for conversion.\n * @group Implementation\n * @category Transactions\n */\nexport function checkOrConvertArgument(\n  arg: SimpleEntryFunctionArgumentTypes | EntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n) {\n  // If the argument is bcs encoded, we can just use it directly\n  if (isEncodedEntryFunctionArgument(arg)) {\n    // Ensure the type matches the ABI\n\n    /**\n     * Checks the type of the provided argument against the expected type.\n     * This function helps validate that the argument conforms to the specified type requirements.\n     *\n     * @param typeArgs - The expected type arguments.\n     * @param arg - The argument to be checked.\n     * @param position - The position of the argument in the context of the check.\n     * @group Implementation\n     * @category Transactions\n     */\n    checkType(param, arg, position);\n    return arg;\n  }\n\n  // If it is not BCS encoded, we will need to convert it with the ABI\n  return parseArg(arg, param, position, genericTypeParams);\n}\n\n/**\n * Parses a non-BCS encoded argument into a BCS encoded argument recursively.\n * This function helps convert various types of input arguments into their corresponding BCS encoded formats based on the\n * specified parameter type.\n *\n * @param arg - The argument to be parsed, which can be of various types.\n * @param param - The type tag that defines the expected type of the argument.\n * @param position - The position of the argument in the function call, used for error reporting.\n * @param genericTypeParams - An array of type tags for generic type parameters, used when the parameter type is generic.\n * @group Implementation\n * @category Transactions\n */\nfunction parseArg(\n  arg: SimpleEntryFunctionArgumentTypes,\n  param: TypeTag,\n  position: number,\n  genericTypeParams: Array<TypeTag>,\n): EntryFunctionArgumentTypes {\n  if (param.isBool()) {\n    if (isBool(arg)) {\n      return new Bool(arg);\n    }\n    if (isString(arg)) {\n      if (arg === \"true\") return new Bool(true);\n      if (arg === \"false\") return new Bool(false);\n    }\n\n    /**\n     * Throws a type mismatch error for the specified move option.\n     *\n     * @param moveOption - The name of the move option that caused the type mismatch.\n     * @param position - The position where the error occurred.\n     * @group Implementation\n     * @category Transactions\n     */\n    throwTypeMismatch(\"boolean\", position);\n  }\n  // TODO: support uint8array?\n  if (param.isAddress()) {\n    if (isString(arg)) {\n      return AccountAddress.fromString(arg);\n    }\n    throwTypeMismatch(\"string | AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U8(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU16()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U16(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU32()) {\n    const num = convertNumber(arg);\n    if (num !== undefined) {\n      return new U32(num);\n    }\n    throwTypeMismatch(\"number | string\", position);\n  }\n  if (param.isU64()) {\n    if (isLargeNumber(arg)) {\n      return new U64(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU128()) {\n    if (isLargeNumber(arg)) {\n      return new U128(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n  if (param.isU256()) {\n    if (isLargeNumber(arg)) {\n      return new U256(BigInt(arg));\n    }\n    throwTypeMismatch(\"bigint | number | string\", position);\n  }\n\n  // Generic needs to use the subtype\n  if (param.isGeneric()) {\n    const genericIndex = param.value;\n    if (genericIndex < 0 || genericIndex >= genericTypeParams.length) {\n      throw new Error(`Generic argument ${param.toString()} is invalid for argument ${position}`);\n    }\n\n    return checkOrConvertArgument(arg, genericTypeParams[genericIndex], position, genericTypeParams);\n  }\n\n  // We have to special case some vectors for Vector<u8>\n  if (param.isVector()) {\n    // Check special case for Vector<u8>\n    if (param.value.isU8()) {\n      // We don't allow vector<u8>, but we convert strings to UTF8 Uint8Array\n      // This is legacy behavior from the original SDK\n      if (isString(arg)) {\n        return MoveVector.U8(TEXT_ENCODER.encode(arg));\n      }\n      if (arg instanceof Uint8Array) {\n        return MoveVector.U8(arg);\n      }\n      if (arg instanceof ArrayBuffer) {\n        return MoveVector.U8(new Uint8Array(arg));\n      }\n    }\n\n    if (isString(arg)) {\n      // In a web env, arguments are passing as strings\n      if (arg.startsWith(\"[\")) {\n        return checkOrConvertArgument(JSON.parse(arg), param, position, genericTypeParams);\n      }\n    }\n\n    // TODO: Support Uint16Array, Uint32Array, BigUint64Array?\n\n    if (Array.isArray(arg)) {\n      return new MoveVector(arg.map((item) => checkOrConvertArgument(item, param.value, position, genericTypeParams)));\n    }\n\n    throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n  }\n\n  // Handle structs as they're more complex\n  if (param.isStruct()) {\n    if (param.isString()) {\n      if (isString(arg)) {\n        return new MoveString(arg);\n      }\n      throwTypeMismatch(\"string\", position);\n    }\n    if (param.isObject()) {\n      // The inner type of Object doesn't matter, since it's just syntactic sugar\n      if (isString(arg)) {\n        return AccountAddress.fromString(arg);\n      }\n      throwTypeMismatch(\"string | AccountAddress\", position);\n    }\n\n    if (param.isOption()) {\n      if (isEmptyOption(arg)) {\n        // Here we attempt to reconstruct the underlying type\n        // Note, for some reason the `isBool` etc. does not work with the compiler\n        const innerParam = param.value.typeArgs[0];\n        if (innerParam instanceof TypeTagBool) {\n          return new MoveOption<Bool>(null);\n        }\n        if (innerParam instanceof TypeTagAddress) {\n          return new MoveOption<AccountAddress>(null);\n        }\n        if (innerParam instanceof TypeTagU8) {\n          return new MoveOption<U8>(null);\n        }\n        if (innerParam instanceof TypeTagU16) {\n          return new MoveOption<U16>(null);\n        }\n        if (innerParam instanceof TypeTagU32) {\n          return new MoveOption<U32>(null);\n        }\n        if (innerParam instanceof TypeTagU64) {\n          return new MoveOption<U64>(null);\n        }\n        if (innerParam instanceof TypeTagU128) {\n          return new MoveOption<U128>(null);\n        }\n        if (innerParam instanceof TypeTagU256) {\n          return new MoveOption<U256>(null);\n        }\n\n        // In all other cases, we will use a placeholder, it doesn't actually matter what the type is, but it will be obvious\n        // Note: This is a placeholder U8 type, and does not match the actual type, as that can't be dynamically grabbed\n        return new MoveOption<MoveString>(null);\n      }\n\n      return new MoveOption(checkOrConvertArgument(arg, param.value.typeArgs[0], position, genericTypeParams));\n    }\n\n    throw new Error(`Unsupported struct input type for argument ${position}, type '${param.toString()}'`);\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, type '${param.toString()}'`);\n}\n\n/**\n * Checks that the type of the BCS encoded argument matches the ABI\n * @param param\n * @param arg\n * @param position\n * @group Implementation\n * @category Transactions\n */\nfunction checkType(param: TypeTag, arg: EntryFunctionArgumentTypes, position: number) {\n  if (param.isBool()) {\n    if (isBcsBool(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"Bool\", position);\n  }\n  if (param.isAddress()) {\n    if (isBcsAddress(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"AccountAddress\", position);\n  }\n  if (param.isU8()) {\n    if (isBcsU8(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U8\", position);\n  }\n  if (param.isU16()) {\n    if (isBcsU16(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U16\", position);\n  }\n  if (param.isU32()) {\n    if (isBcsU32(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U32\", position);\n  }\n  if (param.isU64()) {\n    if (isBcsU64(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U64\", position);\n  }\n  if (param.isU128()) {\n    if (isBcsU128(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U128\", position);\n  }\n  if (param.isU256()) {\n    if (isBcsU256(arg)) {\n      return;\n    }\n    throwTypeMismatch(\"U256\", position);\n  }\n  if (param.isVector()) {\n    if (arg instanceof MoveVector) {\n      // If there's anything in it, check that the inner types match\n      // Note that since it's typed, the first item should be the same as the rest\n      if (arg.values.length > 0) {\n        checkType(param.value, arg.values[0], position);\n      }\n\n      return;\n    }\n    throwTypeMismatch(\"MoveVector\", position);\n  }\n\n  // Handle structs as they're more complex\n  if (param instanceof TypeTagStruct) {\n    if (param.isString()) {\n      if (isBcsString(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"MoveString\", position);\n    }\n    if (param.isObject()) {\n      if (isBcsAddress(arg)) {\n        return;\n      }\n      throwTypeMismatch(\"AccountAddress\", position);\n    }\n    if (param.isOption()) {\n      if (arg instanceof MoveOption) {\n        // If there's a value, we can check the inner type (otherwise it doesn't really matter)\n        if (arg.value !== undefined) {\n          checkType(param.value.typeArgs[0], arg.value, position);\n        }\n        return;\n      }\n      throwTypeMismatch(\"MoveOption\", position);\n    }\n  }\n\n  throw new Error(`Type mismatch for argument ${position}, expected '${param.toString()}'`);\n}\n"],"mappings":"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","names":["TEXT_ENCODER","standardizeTypeTags","typeArguments","typeArg","isString","parseTypeTag","fetchFunctionAbi","moduleAddress","moduleName","functionName","aptosConfig","module","getModule","func","fetchMoveFunctionAbi","functionAbi","params","i","fetchEntryFunctionAbi","numSigners","findFirstNonSignerArg","fetchViewFunctionAbi","returnTypes","convertCallArgument","argument","position","genericTypeParams","CallArgument","convertArgument","arg","param","checkOrConvertArgument","isEncodedEntryFunctionArgument","checkType","parseArg","isBool","Bool","throwTypeMismatch","AccountAddress","num","convertNumber","U8","U16","U32","isLargeNumber","U64","U128","U256","genericIndex","MoveVector","item","MoveString","isEmptyOption","innerParam","TypeTagBool","MoveOption","TypeTagAddress","TypeTagU8","TypeTagU16","TypeTagU32","TypeTagU64","TypeTagU128","TypeTagU256","isBcsBool","isBcsAddress","isBcsU8","isBcsU16","isBcsU32","isBcsU64","isBcsU128","isBcsU256","TypeTagStruct","isBcsString"]}