{"version":3,"sources":["../../src/transactions/scriptComposer/index.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { ScriptComposerWasm } from \"@aptos-labs/script-composer-pack\";\nimport { AptosApiType, getFunctionParts } from \"../../utils\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { InputBatchedFunctionData } from \"../types\";\nimport { fetchMoveFunctionAbi, standardizeTypeTags } from \"../transactionBuilder\";\nimport { CallArgument } from \"../../types\";\nimport { convertCallArgument } from \"../transactionBuilder/remoteAbi\";\n\n/**\n * A wrapper class around TransactionComposer, which is a WASM library compiled\n * from aptos-core/aptos-move/script-composer.\n * This class allows the SDK caller to build a transaction that invokes multiple Move functions\n * and allow for arguments to be passed around.\n * */\nexport class AptosScriptComposer {\n  private config: AptosConfig;\n\n  private builder?: any;\n\n  private static transactionComposer?: any;\n\n  constructor(aptosConfig: AptosConfig) {\n    this.config = aptosConfig;\n    this.builder = undefined;\n  }\n\n  // Initializing the wasm needed for the script composer, must be called\n  // before using the composer.\n  async init() {\n    if (!AptosScriptComposer.transactionComposer) {\n      const module = await import(\"@aptos-labs/script-composer-pack\");\n      const { TransactionComposer, initSync } = module;\n      if (!ScriptComposerWasm.isInitialized) {\n        ScriptComposerWasm.init();\n      }\n      initSync({ module: ScriptComposerWasm.wasm });\n      AptosScriptComposer.transactionComposer = TransactionComposer;\n    }\n    this.builder = AptosScriptComposer.transactionComposer.single_signer();\n  }\n\n  // Add a move function invocation to the TransactionComposer.\n  //\n  // Similar to how to create an entry function, the difference is that input arguments could\n  // either be a `CallArgument` which represents an abstract value returned from a previous Move call\n  // or the regular entry function arguments.\n  //\n  // The function would also return a list of `CallArgument` that can be passed on to future calls.\n  async addBatchedCalls(input: InputBatchedFunctionData): Promise<CallArgument[]> {\n    const { moduleAddress, moduleName, functionName } = getFunctionParts(input.function);\n    const nodeUrl = this.config.getRequestUrl(AptosApiType.FULLNODE);\n\n    // Load the calling module into the builder.\n    await this.builder.load_module(nodeUrl, `${moduleAddress}::${moduleName}`);\n\n    // Load the calling type arguments into the loader.\n    if (input.typeArguments !== undefined) {\n      await Promise.all(input.typeArguments.map((typeTag) => this.builder.load_type_tag(nodeUrl, typeTag.toString())));\n    }\n    const typeArguments = standardizeTypeTags(input.typeArguments);\n    const functionAbi = await fetchMoveFunctionAbi(moduleAddress, moduleName, functionName, this.config);\n    // Check the type argument count against the ABI\n    if (typeArguments.length !== functionAbi.typeParameters.length) {\n      throw new Error(\n        `Type argument count mismatch, expected ${functionAbi.typeParameters.length}, received ${typeArguments.length}`,\n      );\n    }\n\n    const functionArguments: CallArgument[] = input.functionArguments.map((arg, i) =>\n      convertCallArgument(arg, functionName, functionAbi, i, typeArguments),\n    );\n\n    return this.builder.add_batched_call(\n      `${moduleAddress}::${moduleName}`,\n      functionName,\n      typeArguments.map((arg) => arg.toString()),\n      functionArguments,\n    );\n  }\n\n  build(): Uint8Array {\n    return this.builder.generate_batched_calls(true);\n  }\n}\n"],"mappings":"gGAGA,OAAS,sBAAAA,MAA0B,mCAc5B,IAAMC,EAAN,MAAMC,CAAoB,CAO/B,YAAYC,EAA0B,CACpC,KAAK,OAASA,EACd,KAAK,QAAU,MACjB,CAIA,MAAM,MAAO,CACX,GAAI,CAACD,EAAoB,oBAAqB,CAC5C,IAAME,EAAS,KAAM,QAAO,kCAAkC,EACxD,CAAE,oBAAAC,EAAqB,SAAAC,CAAS,EAAIF,EACrCG,EAAmB,eACtBA,EAAmB,KAAK,EAE1BD,EAAS,CAAE,OAAQC,EAAmB,IAAK,CAAC,EAC5CL,EAAoB,oBAAsBG,CAC5C,CACA,KAAK,QAAUH,EAAoB,oBAAoB,cAAc,CACvE,CASA,MAAM,gBAAgBM,EAA0D,CAC9E,GAAM,CAAE,cAAAC,EAAe,WAAAC,EAAY,aAAAC,CAAa,EAAIC,EAAiBJ,EAAM,QAAQ,EAC7EK,EAAU,KAAK,OAAO,wBAAmC,EAG/D,MAAM,KAAK,QAAQ,YAAYA,EAAS,GAAGJ,CAAa,KAAKC,CAAU,EAAE,EAGrEF,EAAM,gBAAkB,QAC1B,MAAM,QAAQ,IAAIA,EAAM,cAAc,IAAKM,GAAY,KAAK,QAAQ,cAAcD,EAASC,EAAQ,SAAS,CAAC,CAAC,CAAC,EAEjH,IAAMC,EAAgBC,EAAoBR,EAAM,aAAa,EACvDS,EAAc,MAAMC,EAAqBT,EAAeC,EAAYC,EAAc,KAAK,MAAM,EAEnG,GAAII,EAAc,SAAWE,EAAY,eAAe,OACtD,MAAM,IAAI,MACR,0CAA0CA,EAAY,eAAe,MAAM,cAAcF,EAAc,MAAM,EAC/G,EAGF,IAAMI,EAAoCX,EAAM,kBAAkB,IAAI,CAACY,EAAKC,IAC1EC,EAAoBF,EAAKT,EAAcM,EAAaI,EAAGN,CAAa,CACtE,EAEA,OAAO,KAAK,QAAQ,iBAClB,GAAGN,CAAa,KAAKC,CAAU,GAC/BC,EACAI,EAAc,IAAKK,GAAQA,EAAI,SAAS,CAAC,EACzCD,CACF,CACF,CAEA,OAAoB,CAClB,OAAO,KAAK,QAAQ,uBAAuB,EAAI,CACjD,CACF","names":["ScriptComposerWasm","AptosScriptComposer","_AptosScriptComposer","aptosConfig","module","TransactionComposer","initSync","ScriptComposerWasm","input","moduleAddress","moduleName","functionName","getFunctionParts","nodeUrl","typeTag","typeArguments","standardizeTypeTags","functionAbi","fetchMoveFunctionAbi","functionArguments","arg","i","convertCallArgument"]}