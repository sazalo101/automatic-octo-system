{"version":3,"sources":["../../src/account/AccountUtils.ts"],"sourcesContent":["import { Deserializer, Serializer } from \"../bcs\";\nimport { AnyPublicKeyVariant, HexInput, SigningScheme } from \"../types\";\nimport { MultiKeyAccount } from \"./MultiKeyAccount\";\nimport { Account } from \"./Account\";\nimport { Ed25519Account } from \"./Ed25519Account\";\nimport { isSingleKeySigner, SingleKeyAccount, SingleKeySignerOrLegacyEd25519Account } from \"./SingleKeyAccount\";\nimport { KeylessAccount } from \"./KeylessAccount\";\nimport { FederatedKeylessAccount } from \"./FederatedKeylessAccount\";\nimport { AbstractKeylessAccount } from \"./AbstractKeylessAccount\";\nimport {\n  AccountAddress,\n  Ed25519PrivateKey,\n  getIssAudAndUidVal,\n  Hex,\n  MultiKey,\n  Secp256k1PrivateKey,\n  ZeroKnowledgeSig,\n} from \"../core\";\nimport { deserializeSchemeAndAddress } from \"./utils\";\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\n\nfunction serializeKeylessAccountCommon(account: AbstractKeylessAccount, serializer: Serializer): void {\n  serializer.serializeStr(account.jwt);\n  serializer.serializeStr(account.uidKey);\n  serializer.serializeFixedBytes(account.pepper);\n  account.ephemeralKeyPair.serialize(serializer);\n  if (account.proof === undefined) {\n    throw new Error(\"Cannot serialize - proof undefined\");\n  }\n  account.proof.serialize(serializer);\n  serializer.serializeOption(account.verificationKeyHash, 32);\n}\n\nfunction deserializeKeylessAccountCommon(deserializer: Deserializer): {\n  jwt: string;\n  uidKey: string;\n  pepper: Uint8Array;\n  ephemeralKeyPair: EphemeralKeyPair;\n  proof: ZeroKnowledgeSig;\n  verificationKeyHash?: Uint8Array;\n} {\n  const jwt = deserializer.deserializeStr();\n  const uidKey = deserializer.deserializeStr();\n  const pepper = deserializer.deserializeFixedBytes(31);\n  const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n  const proof = ZeroKnowledgeSig.deserialize(deserializer);\n  const verificationKeyHash = deserializer.deserializeOption(\"fixedBytes\", 32);\n  return { jwt, uidKey, pepper, ephemeralKeyPair, proof, verificationKeyHash };\n}\n\n/**\n * Utility functions for working with accounts.\n */\nexport namespace AccountUtils {\n  export function toBytes(account: Account): Uint8Array {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(account.signingScheme);\n    account.accountAddress.serialize(serializer);\n    switch (account.signingScheme) {\n      case SigningScheme.Ed25519:\n        (account as Ed25519Account).privateKey.serialize(serializer);\n        return serializer.toUint8Array();\n      case SigningScheme.SingleKey: {\n        if (!isSingleKeySigner(account)) {\n          throw new Error(\"Account is not a SingleKeySigner\");\n        }\n        const anyPublicKey = account.getAnyPublicKey();\n        serializer.serializeU32AsUleb128(anyPublicKey.variant);\n        switch (anyPublicKey.variant) {\n          case AnyPublicKeyVariant.Keyless: {\n            const keylessAccount = account as KeylessAccount;\n            serializeKeylessAccountCommon(keylessAccount, serializer);\n            return serializer.toUint8Array();\n          }\n          case AnyPublicKeyVariant.FederatedKeyless: {\n            const federatedKeylessAccount = account as FederatedKeylessAccount;\n            serializeKeylessAccountCommon(federatedKeylessAccount, serializer);\n            federatedKeylessAccount.publicKey.jwkAddress.serialize(serializer);\n            serializer.serializeBool(federatedKeylessAccount.audless);\n            return serializer.toUint8Array();\n          }\n          case AnyPublicKeyVariant.Secp256k1:\n          case AnyPublicKeyVariant.Ed25519: {\n            const singleKeyAccount = account as SingleKeyAccount;\n            singleKeyAccount.privateKey.serialize(serializer);\n            return serializer.toUint8Array();\n          }\n          default: {\n            throw new Error(`Invalid public key variant: ${anyPublicKey.variant}`);\n          }\n        }\n      }\n      case SigningScheme.MultiKey: {\n        const multiKeyAccount = account as MultiKeyAccount;\n        multiKeyAccount.publicKey.serialize(serializer);\n        serializer.serializeU32AsUleb128(multiKeyAccount.signers.length);\n        multiKeyAccount.signers.forEach((signer) => {\n          serializer.serializeFixedBytes(toBytes(signer));\n        });\n        return serializer.toUint8Array();\n      }\n      default:\n        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${account.signingScheme}`);\n    }\n  }\n\n  export function toHexStringWithoutPrefix(account: Account): string {\n    return Hex.hexInputToStringWithoutPrefix(toBytes(account));\n  }\n\n  export function toHexString(account: Account): string {\n    return Hex.hexInputToString(toBytes(account));\n  }\n\n  export function deserialize(deserializer: Deserializer): Account {\n    const { address, signingScheme } = deserializeSchemeAndAddress(deserializer);\n    switch (signingScheme) {\n      case SigningScheme.Ed25519: {\n        const privateKey = Ed25519PrivateKey.deserialize(deserializer);\n        return new Ed25519Account({ privateKey, address });\n      }\n      case SigningScheme.SingleKey: {\n        const variantIndex = deserializer.deserializeUleb128AsU32();\n        switch (variantIndex) {\n          case AnyPublicKeyVariant.Ed25519: {\n            const privateKey = Ed25519PrivateKey.deserialize(deserializer);\n            return new SingleKeyAccount({ privateKey, address });\n          }\n          case AnyPublicKeyVariant.Secp256k1: {\n            const privateKey = Secp256k1PrivateKey.deserialize(deserializer);\n            return new SingleKeyAccount({ privateKey, address });\n          }\n          case AnyPublicKeyVariant.Keyless: {\n            const keylessComponents = deserializeKeylessAccountCommon(deserializer);\n            const jwtClaims = getIssAudAndUidVal(keylessComponents);\n            return new KeylessAccount({ ...keylessComponents, ...jwtClaims });\n          }\n          case AnyPublicKeyVariant.FederatedKeyless: {\n            const keylessComponents = deserializeKeylessAccountCommon(deserializer);\n            const jwkAddress = AccountAddress.deserialize(deserializer);\n            const audless = deserializer.deserializeBool();\n            const jwtClaims = getIssAudAndUidVal(keylessComponents);\n            return new FederatedKeylessAccount({ ...keylessComponents, ...jwtClaims, jwkAddress, audless });\n          }\n          default:\n            throw new Error(`Unsupported public key variant ${variantIndex}`);\n        }\n      }\n      case SigningScheme.MultiKey: {\n        const multiKey = MultiKey.deserialize(deserializer);\n        const length = deserializer.deserializeUleb128AsU32();\n        const signers = new Array<SingleKeySignerOrLegacyEd25519Account>();\n        for (let i = 0; i < length; i += 1) {\n          const signer = deserialize(deserializer);\n          if (!isSingleKeySigner(signer) && !(signer instanceof Ed25519Account)) {\n            throw new Error(\n              \"Deserialization of MultiKeyAccount failed. Signer is not a SingleKeySigner or Ed25519Account\",\n            );\n          }\n          signers.push(signer);\n        }\n        return new MultiKeyAccount({ multiKey, signers, address });\n      }\n      default:\n        throw new Error(`Deserialization of Account failed: invalid signingScheme value ${signingScheme}`);\n    }\n  }\n\n  export function keylessAccountFromHex(hex: HexInput): KeylessAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof KeylessAccount)) {\n      throw new Error(\"Deserialization of KeylessAccount failed\");\n    }\n    return account;\n  }\n\n  export function federatedKeylessAccountFromHex(hex: HexInput): FederatedKeylessAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof FederatedKeylessAccount)) {\n      throw new Error(\"Deserialization of FederatedKeylessAccount failed\");\n    }\n    return account;\n  }\n\n  export function multiKeyAccountFromHex(hex: HexInput): MultiKeyAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof MultiKeyAccount)) {\n      throw new Error(\"Deserialization of MultiKeyAccount failed\");\n    }\n    return account;\n  }\n\n  export function singleKeyAccountFromHex(hex: HexInput): SingleKeyAccount {\n    const account = fromHex(hex);\n    if (!(account instanceof SingleKeyAccount)) {\n      throw new Error(\"Deserialization of SingleKeyAccount failed\");\n    }\n    return account;\n  }\n\n  export function ed25519AccountFromHex(hex: HexInput): Ed25519Account {\n    const account = fromHex(hex);\n    if (!(account instanceof Ed25519Account)) {\n      throw new Error(\"Deserialization of Ed25519Account failed\");\n    }\n    return account;\n  }\n\n  export function fromHex(hex: HexInput): Account {\n    return deserialize(Deserializer.fromHex(hex));\n  }\n\n  export function fromBytes(bytes: Uint8Array): Account {\n    return fromHex(bytes);\n  }\n}\n"],"mappings":"gnBAqBA,SAASA,EAA8BC,EAAiCC,EAA8B,CAKpG,GAJAA,EAAW,aAAaD,EAAQ,GAAG,EACnCC,EAAW,aAAaD,EAAQ,MAAM,EACtCC,EAAW,oBAAoBD,EAAQ,MAAM,EAC7CA,EAAQ,iBAAiB,UAAUC,CAAU,EACzCD,EAAQ,QAAU,OACpB,MAAM,IAAI,MAAM,oCAAoC,EAEtDA,EAAQ,MAAM,UAAUC,CAAU,EAClCA,EAAW,gBAAgBD,EAAQ,oBAAqB,EAAE,CAC5D,CAEA,SAASE,EAAgCC,EAOvC,CACA,IAAMC,EAAMD,EAAa,eAAe,EAClCE,EAASF,EAAa,eAAe,EACrCG,EAASH,EAAa,sBAAsB,EAAE,EAC9CI,EAAmBC,EAAiB,YAAYL,CAAY,EAC5DM,EAAQC,EAAiB,YAAYP,CAAY,EACjDQ,EAAsBR,EAAa,kBAAkB,aAAc,EAAE,EAC3E,MAAO,CAAE,IAAAC,EAAK,OAAAC,EAAQ,OAAAC,EAAQ,iBAAAC,EAAkB,MAAAE,EAAO,oBAAAE,CAAoB,CAC7E,CAKO,IAAUC,MAAV,CACE,SAASC,EAAQb,EAA8B,CACpD,IAAMC,EAAa,IAAIa,EAGvB,OAFAb,EAAW,sBAAsBD,EAAQ,aAAa,EACtDA,EAAQ,eAAe,UAAUC,CAAU,EACnCD,EAAQ,cAAe,CAC7B,OACE,OAACA,EAA2B,WAAW,UAAUC,CAAU,EACpDA,EAAW,aAAa,EACjC,OAA8B,CAC5B,GAAI,CAACc,EAAkBf,CAAO,EAC5B,MAAM,IAAI,MAAM,kCAAkC,EAEpD,IAAMgB,EAAehB,EAAQ,gBAAgB,EAE7C,OADAC,EAAW,sBAAsBe,EAAa,OAAO,EAC7CA,EAAa,QAAS,CAC5B,OAEE,OAAAjB,EADuBC,EACuBC,CAAU,EACjDA,EAAW,aAAa,EAEjC,OAA2C,CACzC,IAAMgB,EAA0BjB,EAChC,OAAAD,EAA8BkB,EAAyBhB,CAAU,EACjEgB,EAAwB,UAAU,WAAW,UAAUhB,CAAU,EACjEA,EAAW,cAAcgB,EAAwB,OAAO,EACjDhB,EAAW,aAAa,CACjC,CACA,OACA,OAEE,OADyBD,EACR,WAAW,UAAUC,CAAU,EACzCA,EAAW,aAAa,EAEjC,QACE,MAAM,IAAI,MAAM,+BAA+Be,EAAa,OAAO,EAAE,CAEzE,CACF,CACA,OAA6B,CAC3B,IAAME,EAAkBlB,EACxB,OAAAkB,EAAgB,UAAU,UAAUjB,CAAU,EAC9CA,EAAW,sBAAsBiB,EAAgB,QAAQ,MAAM,EAC/DA,EAAgB,QAAQ,QAASC,GAAW,CAC1ClB,EAAW,oBAAoBY,EAAQM,CAAM,CAAC,CAChD,CAAC,EACMlB,EAAW,aAAa,CACjC,CACA,QACE,MAAM,IAAI,MAAM,kEAAkED,EAAQ,aAAa,EAAE,CAC7G,CACF,CAlDOY,EAAS,QAAAC,EAoDT,SAASO,EAAyBpB,EAA0B,CACjE,OAAOqB,EAAI,8BAA8BR,EAAQb,CAAO,CAAC,CAC3D,CAFOY,EAAS,yBAAAQ,EAIT,SAASE,EAAYtB,EAA0B,CACpD,OAAOqB,EAAI,iBAAiBR,EAAQb,CAAO,CAAC,CAC9C,CAFOY,EAAS,YAAAU,EAIT,SAASC,EAAYpB,EAAqC,CAC/D,GAAM,CAAE,QAAAqB,EAAS,cAAAC,CAAc,EAAIC,EAA4BvB,CAAY,EAC3E,OAAQsB,EAAe,CACrB,OAA4B,CAC1B,IAAME,EAAaC,EAAkB,YAAYzB,CAAY,EAC7D,OAAO,IAAI0B,EAAe,CAAE,WAAAF,EAAY,QAAAH,CAAQ,CAAC,CACnD,CACA,OAA8B,CAC5B,IAAMM,EAAe3B,EAAa,wBAAwB,EAC1D,OAAQ2B,EAAc,CACpB,OAAkC,CAChC,IAAMH,EAAaC,EAAkB,YAAYzB,CAAY,EAC7D,OAAO,IAAI4B,EAAiB,CAAE,WAAAJ,EAAY,QAAAH,CAAQ,CAAC,CACrD,CACA,OAAoC,CAClC,IAAMG,EAAaK,EAAoB,YAAY7B,CAAY,EAC/D,OAAO,IAAI4B,EAAiB,CAAE,WAAAJ,EAAY,QAAAH,CAAQ,CAAC,CACrD,CACA,OAAkC,CAChC,IAAMS,EAAoB/B,EAAgCC,CAAY,EAChE+B,EAAYC,EAAmBF,CAAiB,EACtD,OAAO,IAAIG,EAAe,CAAE,GAAGH,EAAmB,GAAGC,CAAU,CAAC,CAClE,CACA,OAA2C,CACzC,IAAMD,EAAoB/B,EAAgCC,CAAY,EAChEkC,EAAaC,EAAe,YAAYnC,CAAY,EACpDoC,EAAUpC,EAAa,gBAAgB,EACvC+B,EAAYC,EAAmBF,CAAiB,EACtD,OAAO,IAAIO,EAAwB,CAAE,GAAGP,EAAmB,GAAGC,EAAW,WAAAG,EAAY,QAAAE,CAAQ,CAAC,CAChG,CACA,QACE,MAAM,IAAI,MAAM,kCAAkCT,CAAY,EAAE,CACpE,CACF,CACA,OAA6B,CAC3B,IAAMW,EAAWC,EAAS,YAAYvC,CAAY,EAC5CwC,EAASxC,EAAa,wBAAwB,EAC9CyC,EAAU,IAAI,MACpB,QAASC,EAAI,EAAGA,EAAIF,EAAQE,GAAK,EAAG,CAClC,IAAM1B,EAASI,EAAYpB,CAAY,EACvC,GAAI,CAACY,EAAkBI,CAAM,GAAK,EAAEA,aAAkBU,GACpD,MAAM,IAAI,MACR,8FACF,EAEFe,EAAQ,KAAKzB,CAAM,CACrB,CACA,OAAO,IAAI2B,EAAgB,CAAE,SAAAL,EAAU,QAAAG,EAAS,QAAApB,CAAQ,CAAC,CAC3D,CACA,QACE,MAAM,IAAI,MAAM,kEAAkEC,CAAa,EAAE,CACrG,CACF,CApDOb,EAAS,YAAAW,EAsDT,SAASwB,EAAsBC,EAA+B,CACnE,IAAMhD,EAAUiD,EAAQD,CAAG,EAC3B,GAAI,EAAEhD,aAAmBoC,GACvB,MAAM,IAAI,MAAM,0CAA0C,EAE5D,OAAOpC,CACT,CANOY,EAAS,sBAAAmC,EAQT,SAASG,EAA+BF,EAAwC,CACrF,IAAMhD,EAAUiD,EAAQD,CAAG,EAC3B,GAAI,EAAEhD,aAAmBwC,GACvB,MAAM,IAAI,MAAM,mDAAmD,EAErE,OAAOxC,CACT,CANOY,EAAS,+BAAAsC,EAQT,SAASC,EAAuBH,EAAgC,CACrE,IAAMhD,EAAUiD,EAAQD,CAAG,EAC3B,GAAI,EAAEhD,aAAmB8C,GACvB,MAAM,IAAI,MAAM,2CAA2C,EAE7D,OAAO9C,CACT,CANOY,EAAS,uBAAAuC,EAQT,SAASC,EAAwBJ,EAAiC,CACvE,IAAMhD,EAAUiD,EAAQD,CAAG,EAC3B,GAAI,EAAEhD,aAAmB+B,GACvB,MAAM,IAAI,MAAM,4CAA4C,EAE9D,OAAO/B,CACT,CANOY,EAAS,wBAAAwC,EAQT,SAASC,EAAsBL,EAA+B,CACnE,IAAMhD,EAAUiD,EAAQD,CAAG,EAC3B,GAAI,EAAEhD,aAAmB6B,GACvB,MAAM,IAAI,MAAM,0CAA0C,EAE5D,OAAO7B,CACT,CANOY,EAAS,sBAAAyC,EAQT,SAASJ,EAAQD,EAAwB,CAC9C,OAAOzB,EAAY+B,EAAa,QAAQN,CAAG,CAAC,CAC9C,CAFOpC,EAAS,QAAAqC,EAIT,SAASM,EAAUC,EAA4B,CACpD,OAAOP,EAAQO,CAAK,CACtB,CAFO5C,EAAS,UAAA2C,IA/JD3C,MAAA","names":["serializeKeylessAccountCommon","account","serializer","deserializeKeylessAccountCommon","deserializer","jwt","uidKey","pepper","ephemeralKeyPair","EphemeralKeyPair","proof","ZeroKnowledgeSig","verificationKeyHash","AccountUtils","toBytes","Serializer","isSingleKeySigner","anyPublicKey","federatedKeylessAccount","multiKeyAccount","signer","toHexStringWithoutPrefix","Hex","toHexString","deserialize","address","signingScheme","deserializeSchemeAndAddress","privateKey","Ed25519PrivateKey","Ed25519Account","variantIndex","SingleKeyAccount","Secp256k1PrivateKey","keylessComponents","jwtClaims","getIssAudAndUidVal","KeylessAccount","jwkAddress","AccountAddress","audless","FederatedKeylessAccount","multiKey","MultiKey","length","signers","i","MultiKeyAccount","keylessAccountFromHex","hex","fromHex","federatedKeylessAccountFromHex","multiKeyAccountFromHex","singleKeyAccountFromHex","ed25519AccountFromHex","Deserializer","fromBytes","bytes"]}